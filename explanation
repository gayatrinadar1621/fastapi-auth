# Alembic

Alembic is a database migration tool for SQLAlchemy.
Alembic helps you change your database structure safely over time
(add columns, remove tables, rename fields, etc.)
It keeps your database schema in sync with your Python models.

Why do we need Alembic?

Imagine this timeline ðŸ‘‡

Day 1
class Book(SQLModel, table=True):
id: int | None = Field(default=None, primary_key=True)
title: str

You create tables â†’ everything works âœ…

Day 10

You update the model:

class Book(SQLModel, table=True):
id: int | None = Field(default=None, primary_key=True)
title: str
author: str

Now the problem ðŸ˜¬
ðŸ‘‰ Database still does NOT have author column

SQLModel.metadata.create_all() âŒ does nothing

App crashes or behaves weirdly

Manually editing DB = risky + unprofessional

ðŸ’¡ This is where Alembic comes in

---

How Alembic works (high level)

Alembic works with versions.

DB v1 â†’ DB v2 â†’ DB v3 â†’ ...

Each change = one migration file.

Example:

v1 â†’ create book table

v2 â†’ add author column

v3 â†’ rename title to name

---

Note :
Use ONLY Alembic for table creation & schema changes
We need not use conn.run_sync(SQLModel.metadata.create_all) and call that function in lifespan event for cteating tables.

Do you need lifespan event if you use Alembic?
âŒ For table creation?

NO

Alembic is run:
manually (alembic upgrade head)
or during deployment / CI-CD
Not at app startup.

---

âœ… When DO you still need lifespan?

Lifespan is still useful for:
Opening DB connection pools
Loading ML models
Connecting to Redis
Initializing background workers

In real apps:

DB migrations are run before starting FastAPI
App assumes schema already exists

---

How to set up alembic?

Before this create .env and src/config.py to read .env data and src/auth/models.py to define our model.
Also we create a new database on postgre --> create database auth_db;
Connect to that database --> \c auth_db

1.  pip install alembic

2.  alembic init -t async migrations
    It creates :
    migrations/
    -- versions/
    -- env.py
    -- README
    -- script.py.mako
    alembic.ini

3.  We add the following in alembic.ini :
    The alembic.ini file contains configurations for Alembic that enable it to interact with our database and project.

         # ---- added by me -----
         from src.auth.models import UserAuthModel
         from sqlmodel import SQLModel
         from src.config import Config
         # ---- added by me -----

         # ---- added by me -----
         database_url = Config.DATABASE_URL
         config.set_main_option("sqlalchemy.url", database_url)
         # ---- added by me -----

         # modified by me
         target_metadata = SQLModel.metadata

4.  Then we add the follwing in migrations/script.py.mako

        # ---- added by me -----
        import sqlmodel
        # ---- added by me -----

5.  let's create our first database migration.
    alembic revision --autogenerate -m "create user auth table"

6.  Apply migration
    alembic upgrade head

7.  switch to auth_db -- \c auth_db
    view created table -- \dt
    view the desc of table -- \d authtable

==================================================================

# Sign up Logic : 

Accept user data (email / username / password)
Hash password
Check if user already exists
Save user in DB
Return success response (not password!)

1. Create model for creating user account --> src/auth/models.py

2. Create connection with database (create engine and session) --> src/db/main.py

3. Create routes --> src/auth/routes.py

4. Build logic for signup --> src/auth/services.py

After basic signup, we need to perform two important things : 
1. On return, the password should not be visisble

   For this, we do password : str = Field(exclude=True) in UserAuthModel. This will exclude the password in response. We cant do this for request as excluding it will give validation error.   


